Group 09 - Final Project
Isaac Woods
Ryan Racine
Aiden O'Keefe

Describe how you solved each variant
Describe the structure of your code: did you reuse stuff across variants?
No need for an intro in which you describe the goal of the project.

Code Structure:
We used approximate Q-Learning to solve each varient in this project.
The main function is the do function which decides which action to take.
The do function uses the calcQ(world, action) function to determine 
what the best next action is. 
If calcQ gets passed an action of -1 it indicates that no action is
to be taken and it should evaluate the features in the current state.
If no action is being taken it evaluates state changes (Explained below)
If calcQ gets passed a valid action, it simulates the world with the 
given move then calculates the Q value for this. If the result is a
terminal state, the reward from this is returned.

State Changes
When creating the bot you pass in a weight array "on" which are used 
as the initial weights and any weights set to 0 in this are ignored 
when in this default state. There is one other state implemented which
is the rush towards exit state (only cares about feature 6 (A* distance
to exit)). The bot switches to this state when it is closer to the exit
than any enemy.

CalcQ calls a general function calcFeatureN() to calculate the value
for any given feature. This function calls the individual calcFeature
functions to calculate the feature values. Below is a list of all 
features we used:

Features
------------------------------------------
feature0: Dummy feature to represent bias
feature1: Manhattan distance to door
feature2: Manhattan distance to bomb in col/row
feature3: number of neighboring walls
feature4: distance from closest side wall
feature5: number bombs on the field
feature6: A*
feature7: Closest enemy
feature8: Closest enemy in range of 4
feature9: Corner detection
feature10: Enemy in range 6 manhattan distance
feature11: Enemy in detection

Feature 1:
Calculates the manhattan distance to the exit. Used mostly in 
Scenario2 to encourage the bot to move towards the exit even 
when a viable path cannot be found

Feature 2:
Calculates the distance from a bomb in the sme colmn or row
within bomb_range. We used this mostly to tell the bot not to
stand near bombs when they are about to explode. This at one point
was creating invisible lines it would not cross even when chased by
an aggressive enemy so we added a delay. This delay told the feature
to ignore bombs whose timers were above a certain point (in the end
1 tick) because bombs are only harmful if youre too close when
they go off.

Feature 3:
Counts the surrounding walls. The idea behind this was to give the
bot some way of knowing it was in a tight spot or in a spot that would
be good to place a bomb in. We didnt end up using this feature.

Feature 4:
Find distance to the closest side wall. This was used early on to 
tell the bot not to get to close to the side walls because these 
limit its movement options. This was eventually mostly replaced by
feature 9.

Feature 5: 
Calculates the number of bombs on the field. This was used to tell the
bot if it should place bombs. The weight associated with this feature
was eventually set to positive resulting in the bot placeing bombs off
cooldown

Feature 6: 
Calculates the A* distance to the exit if a path exists. This was used 
as the main feature to drive the bot toward the goal, especially in the
first varient. 

Feature 7: 
Calculates the A* distance to the closest enemy on the board. This was
the first feature implemented to try to keep the bot away from the 
enemies. The bot doesnt care too much about enemies really far away
which this still detected so the weight was  kept low for most varients
which favored the following features which limit the max range of 
detection

Feature 8:
It calculates the A* distance to the closest enemy same as feature 7
except it only considers enemies within 4 steps of A*. This is helpful 
because the enemy doesnt care about enemies too far away

Feature 9:
It calculates a value that is supposed to represent how cornered the
bot is. it calculates this using the distance from the closest obstacle
on the left or right and the closest obstacle on the top or bottom. This
was a useful feature for telling the bot not to put itself in situations
that could easy cause it to be trapped and die.

This code was reused for each varient with just different weights
We also added 3 things to the constructor of the character:
active_features is used to set initial weights and determine the 
  "on" array
decay is used only for learning
lr is also only used for learning

Learning was to slow and sporatic to make it truely feasible in
this project so the weights were adjusted and tested by hand. The 
final weights for each varient resut in these results over 100 games:

Results:
Wins:Games (win percentage) 
------------------------------
Scenario 1:
Varient 1: 100:100 (100%)
Varient 2: 99:100 (99%)
Varient 3: 93:99 (93.93939393939394%)
Varient 4: 80:100 (80%)
Varient 5: 85:100 (85%)

Scenario 2:
Varient 1: 100:100 (100%)
Varient 2: 100:100 (100%)
Varient 3: 100:100 (100%)
Varient 4: 96:100 (96%)
Varient 5: 88:100 (88%)